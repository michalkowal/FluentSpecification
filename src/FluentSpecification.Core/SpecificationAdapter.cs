using System;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using FluentSpecification.Abstractions;
using FluentSpecification.Abstractions.Generic;
using FluentSpecification.Abstractions.Validation;
using FluentSpecification.Core.Validation;
using JetBrains.Annotations;

namespace FluentSpecification.Core
{
    /// <summary>
    ///     Internal adapter, extends <c>Specification</c> object to complex <c>Specification</c>.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    internal sealed class SpecificationAdapter<T> :
        IComplexSpecification<T>,
        IComplexNegatableSpecification<T>
    {
        private readonly ISpecification<T> _baseSpecification;

        /// <summary>
        ///     Creates adapter.
        /// </summary>
        /// <param name="specification">Base non-complex <c>Specification</c>.</param>
        /// <exception cref="ArgumentException">
        ///     Thrown when <c>Specification</c> already implements
        ///     <see cref="IComplexSpecification{T}" />
        /// </exception>
        public SpecificationAdapter([NotNull] ISpecification<T> specification)
        {
            _baseSpecification = specification ?? throw new ArgumentNullException(nameof(specification));
            if (specification is IComplexSpecification<T>)
                throw new ArgumentException("Incorrect specification type", nameof(specification));
        }

        /// <inheritdoc />
        public bool IsSatisfiedBy(T candidate)
        {
            return _baseSpecification.IsSatisfiedBy(candidate);
        }

        /// <summary>
        ///     Checks if <c>Specification</c> is satisfied by <paramref name="candidate" /> object.
        ///     Returns validation <paramref name="result" /> no matter is satisfied or not.
        /// </summary>
        /// <remarks>
        ///     If base <c>Specification</c> is not <see cref="IValidationSpecification{T}" /> -
        ///     <paramref name="result" /> is generated by adapter.
        /// </remarks>
        /// <param name="candidate">Candidate object to verification.</param>
        /// <param name="result">
        ///     Contains validation summary - errors, types of all executed <c>Specifications</c>
        ///     and trace message in the style of Boole algebra.
        /// </param>
        /// <returns>
        ///     <para>true - <c>Specification</c> is satisfied by <paramref name="candidate" />.</para>
        ///     <para>false - is not. <paramref name="result" /> should contains errors.</para>
        /// </returns>
        public bool IsSatisfiedBy(T candidate, out SpecificationResult result)
        {
            if (_baseSpecification is IValidationSpecification<T> specification)
                return specification.IsSatisfiedBy(candidate, out result);

            var overall = IsSatisfiedBy(candidate);

            result = CreateResult(candidate, overall, false);

            return overall;
        }

        /// <summary>
        ///     Gets typed lambda <c>Linq</c> Expression with candidate object verification.
        /// </summary>
        /// <remarks>
        ///     If base <c>Specification</c> is not <see cref="ILinqSpecification{T}" /> -
        ///     <c>Expression</c> is generated by adapter (as <see cref="IsSatisfiedBy(T)" /> invoke).
        /// </remarks>
        /// <returns>Strongly typed lambda <c>Linq</c> Expression.</returns>
        public Expression<Func<T, bool>> GetExpression()
        {
            if (_baseSpecification is ILinqSpecification<T> specification) return specification.GetExpression();

            return GetExpression(false);
        }

        /// <inheritdoc />
        Expression ILinqSpecification.GetExpression()
        {
            return GetExpression();
        }

        /// <summary>
        ///     Gets typed lambda <c>Linq</c> Expression with candidate object verification.
        /// </summary>
        /// <remarks>
        ///     If base <c>Specification</c> is not <see cref="INegatableLinqSpecification{T}" /> -
        ///     <c>Expression</c> is generated by adapter.
        /// </remarks>
        /// <returns>Strongly typed lambda <c>Linq</c> Expression.</returns>
        public Expression<Func<T, bool>> GetNegationExpression()
        {
            if (_baseSpecification is INegatableLinqSpecification<T> negatableSpecification)
                return negatableSpecification.GetNegationExpression();

            return GetExpression(true);
        }

        /// <summary>
        ///     Checks if <c>Specification</c> is NOT satisfied by <paramref name="candidate" /> object.
        /// </summary>
        /// <remarks>
        ///     If base <c>Specification</c> is not <see cref="INegatableSpecification{T}" /> -
        ///     result is generated by negation of <see cref="IsSatisfiedBy(T)" />.
        /// </remarks>
        /// <param name="candidate">Candidate object to verification.</param>
        /// <returns>
        ///     <para>true - <c>Specification</c> is NOT satisfied by <paramref name="candidate" />.</para>
        ///     <para>false - is satisfied.</para>
        /// </returns>
        public bool IsNotSatisfiedBy(T candidate)
        {
            if (_baseSpecification is INegatableSpecification<T> negatableSpecification)
                return negatableSpecification.IsNotSatisfiedBy(candidate);
            return !IsSatisfiedBy(candidate);
        }

        /// <summary>
        ///     Checks if <c>Specification</c> is NOT satisfied by <paramref name="candidate" /> object.
        ///     Returns validation <paramref name="result" /> no matter is satisfied or not.
        /// </summary>
        /// <remarks>
        ///     If base <c>Specification</c> is not <see cref="INegatableValidationSpecification{T}" /> -
        ///     <paramref name="result" /> is generated by adapter.
        /// </remarks>
        /// <param name="candidate">Candidate object to verification.</param>
        /// <param name="result">
        ///     Contains validation summary - errors, types of all executed <c>Specifications</c>
        ///     and trace message in the style of Boole algebra.
        /// </param>
        /// <returns>
        ///     <para>true - <c>Specification</c> is NOT satisfied by <paramref name="candidate" />.</para>
        ///     <para>false - is satisfied. <paramref name="result" /> should contains errors.</para>
        /// </returns>
        public bool IsNotSatisfiedBy(T candidate, out SpecificationResult result)
        {
            if (_baseSpecification is INegatableValidationSpecification<T> negatableSpecification)
                return negatableSpecification.IsNotSatisfiedBy(candidate, out result);

            var overall = IsNotSatisfiedBy(candidate);

            result = CreateResult(candidate, overall, true);

            return overall;
        }

        [NotNull]
        private string CreateFailedMessage(bool isNegation)
        {
            if (!isNegation)
                return
                    $"Specification [{_baseSpecification.GetShortName()}] is not satisfied by candidate";
            return
                $"Specification [{_baseSpecification.GetShortName()}] is satisfied by candidate";
        }

        private SpecificationTrace CreateTraceMessage(bool result, bool isNegation)
        {
            SpecificationTrace trace = new CommonSpecificationTrace(_baseSpecification, result);

            if (isNegation)
            {
                trace = new SpecificationTrace($"Not{trace.FullTrace}", $"Not{trace.ShortTrace}");
            }

            return trace;
        }

        [NotNull]
        private SpecificationResult CreateResult([CanBeNull] T candidate, bool overall, bool isNegation)
        {
            var trace = CreateTraceMessage(overall, isNegation);
            string[] errors = null;
            if (!overall)
            {
                errors = new[] { CreateFailedMessage(isNegation) };
            }

            var info = new SpecificationInfo(overall, _baseSpecification.GetType(),
                isNegation, null, candidate, errors);

            return new SpecificationResult(overall, trace, info);
        }

        private MethodInfo GetBaseSpecificationMethodInfo(string methodName, Type specType)
        {
            var result = specType.GetTypeInfo()
                       .GetDeclaredMethods(methodName)
                       .FirstOrDefault(m => m.ReturnParameter != null &&
                                            m.ReturnParameter.ParameterType == typeof(bool) &&
                                            m.GetParameters().Length == 1 &&
                                            m.GetParameters().First().ParameterType == typeof(T));

            if (result == null && specType.GetTypeInfo().BaseType != null)
            {
                result = GetBaseSpecificationMethodInfo(methodName, specType.GetTypeInfo().BaseType);
            }

            return result ?? specType.GetTypeInfo()
                       .GetDeclaredMethods(methodName)
                       .FirstOrDefault(m => m.ReturnParameter != null &&
                                            m.ReturnParameter.ParameterType == typeof(bool) &&
                                            m.GetParameters().Length == 1 &&
                                            m.GetParameters().First().ParameterType.GetTypeInfo()
                                                .IsAssignableFrom(typeof(T).GetTypeInfo()));
        }

        private MethodInfo GetIsNotSatisfiedByMethodInfo(Type specType)
        {
            return GetBaseSpecificationMethodInfo(nameof(INegatableSpecification<T>.IsNotSatisfiedBy), specType);
        }

        private MethodInfo GetIsSatisfiedByMethodInfo(Type specType)
        {
            return GetBaseSpecificationMethodInfo(nameof(ISpecification<T>.IsSatisfiedBy), specType);
        }

        [NotNull]
        private Expression<Func<T, bool>> GetExpression(bool negatable)
        {
            var arg = Expression.Parameter(typeof(T), "candidate");

            Expression callExpression;
            if (negatable && _baseSpecification is INegatableSpecification<T> negatableSpecification)
            {
                var funcInfo = GetIsNotSatisfiedByMethodInfo(negatableSpecification.GetType());
                callExpression = Expression.Call(Expression.Constant(_baseSpecification), funcInfo, arg);
            }
            else
            {
                var funcInfo = GetIsSatisfiedByMethodInfo(_baseSpecification.GetType());
                if (negatable)
                    callExpression =
                        Expression.Not(Expression.Call(Expression.Constant(_baseSpecification), funcInfo, arg));
                else
                    callExpression = Expression.Call(Expression.Constant(_baseSpecification), funcInfo, arg);
            }

            return Expression.Lambda<Func<T, bool>>(callExpression, arg);
        }

        /// <summary>
        ///     Conversion operator from <c>Specification</c> to <see cref="Expression{Func}" />.
        /// </summary>
        /// <param name="self">Converted object</param>
        /// <exception cref="NullReferenceException">Thrown when <paramref name="self" /> is null.</exception>
        [PublicAPI]
        [CanBeNull]
        public static implicit operator Expression<Func<T, bool>>([CanBeNull] SpecificationAdapter<T> self)
        {
            return self?.GetExpression();
        }

        /// <summary>
        ///     Conversion operator from <c>Specification</c> to <see cref="Func{T, Boolean}" />.
        /// </summary>
        /// <param name="self">Converted object</param>
        /// <exception cref="ArgumentException">Thrown when <paramref name="self" /> is null.</exception>
        [PublicAPI]
        [CanBeNull]
        public static implicit operator Func<T, bool>([CanBeNull] SpecificationAdapter<T> self)
        {
            return self != null ? self.IsSatisfiedBy : (Func<T, bool>)null;
        }

        /// <summary>
        ///     Conversion operator from <c>Specification</c> to <see cref="Expression" />.
        /// </summary>
        /// <param name="self">Converted object</param>
        /// <exception cref="NullReferenceException">Thrown when <paramref name="self" /> is null.</exception>
        [PublicAPI]
        [CanBeNull]
        public static explicit operator Expression([CanBeNull] SpecificationAdapter<T> self)
        {
            return ((ILinqSpecification) self)?.GetExpression();
        }
    }
}